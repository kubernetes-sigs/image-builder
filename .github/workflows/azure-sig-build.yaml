# Reusable workflow for building Azure SIG images
#
# This workflow builds a Kubernetes node image and publishes it to a staging
# Azure Compute Gallery.

name: Build Azure SIG Image

on:
  workflow_call:
    inputs:
      kubernetes_version:
        description: 'Kubernetes version (e.g., 1.31.1)'
        required: true
        type: string
      os:
        description: 'Operating system (Ubuntu, AzureLinux, Windows)'
        required: true
        type: string
      os_version:
        description: 'OS version (e.g., 24.04, 2022-containerd)'
        required: true
        type: string
      resource_group:
        description: 'Azure resource group name'
        required: false
        type: string
        default: 'cluster-api-gallery'
      staging_gallery_name:
        description: 'Staging gallery name'
        required: false
        type: string
        default: 'staging_gallery'
      packer_flags:
        description: 'Additional Packer flags'
        required: false
        type: string
        default: ''
      tags:
        description: 'Tags to apply to the image'
        required: false
        type: string
        default: ''
    outputs:
      publishing_info:
        description: 'JSON object containing image publishing information'
        value: ${{ jobs.build_sig.outputs.publishing_info }}

permissions:
  id-token: write
  contents: read

jobs:
  build_sig:
    name: Build SIG Image
    runs-on: ubuntu-latest
    timeout-minutes: 120
    outputs:
      publishing_info: ${{ steps.publishing_info.outputs.info }}
    env:
      KUBERNETES_VERSION: ${{ inputs.kubernetes_version }}
      OS: ${{ inputs.os }}
      OS_VERSION: ${{ inputs.os_version }}
      RESOURCE_GROUP: ${{ inputs.resource_group }}
      STAGING_GALLERY_NAME: ${{ inputs.staging_gallery_name }}
      PACKER_FLAGS: ${{ inputs.packer_flags }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure Kubernetes version
        working-directory: images/capi/packer/config
        run: |
          KUBERNETES_RELEASE=$(echo ${KUBERNETES_VERSION} | cut -d "." -f -2)
          sed -i "s/^  \"kubernetes_series\".*/  \"kubernetes_series\": \"v${KUBERNETES_RELEASE}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_semver\".*/  \"kubernetes_semver\": \"v${KUBERNETES_VERSION}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_rpm_version\".*/  \"kubernetes_rpm_version\": \"${KUBERNETES_VERSION}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_deb_version\".*/  \"kubernetes_deb_version\": \"${KUBERNETES_VERSION}-1.1\",/g" kubernetes.json
          cat kubernetes.json

      - name: Check for Windows kube-proxy image
        if: inputs.os == 'Windows'
        run: |
          set -euo pipefail
          kube_proxy_url="sigwindowstools/kube-proxy:v${KUBERNETES_VERSION/+/_}-calico-hostprocess"
          echo "Checking for Windows kube-proxy image $kube_proxy_url"
          if ! stderr="$(docker pull $kube_proxy_url 2>&1 > /dev/null)"; then
            # It's a Windows image, so expect an error after pulling it on Linux
            if [[ $stderr != *"cannot be used on this platform"* ]]; then
              echo "Failed to pull kube-proxy image: $stderr"
              exit 1
            fi
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        working-directory: images/capi
        run: |
          pip install ansible ansible-lint
          make deps-azure

      - name: Build SIG Image
        id: build
        working-directory: images/capi
        run: |
          set -euo pipefail

          os=$(echo "${OS}" | tr '[:upper:]' '[:lower:]')
          version=$(echo "${OS_VERSION}" | tr '[:upper:]' '[:lower:]' | tr -d .)

          export RESOURCE_GROUP="${RESOURCE_GROUP:-cluster-api-gallery}"
          export RESOURCE_GROUP_NAME="${RESOURCE_GROUP}"

          # timestamp is in RFC-3339 format to match kubetest
          export TIMESTAMP="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
          export JOB_NAME="${JOB_NAME:-"image-builder-sig-${os}-${version}"}"

          if [[ -n "${{ inputs.tags }}" ]]; then
            export TAGS="${{ inputs.tags }}"
          else
            export TAGS="creationTimestamp=${TIMESTAMP} jobName=${JOB_NAME} DO-NOT-DELETE=UpstreamInfra"
          fi
          printf "${TAGS}" | tee packer/azure/tags.out

          export GALLERY_NAME="${STAGING_GALLERY_NAME:-staging_gallery}"
          DISTRO="${os}-${version}"
          echo "DISTRO=${DISTRO}" >> $GITHUB_ENV

          export PACKER_FLAGS="${PACKER_FLAGS} --var sig_image_version=${KUBERNETES_VERSION}"
          export PATH=$PATH:$HOME/.local/bin
          export USE_AZURE_CLI_AUTH="True"

          make build-azure-sig-${os}-${version} | tee packer/azure/packer.out

      - name: Generate SIG publishing info
        id: publishing_info
        working-directory: images/capi
        run: |
          set -euo pipefail

          PACKER_OUTPUT=packer/azure/packer.out
          OS_TYPE=$(sed -n 's/^OSType: \(.*\)/\1/p' $PACKER_OUTPUT | tail -1)
          MANAGED_IMAGE_RESOURCE_GROUP_NAME=$(sed -n "s/^ManagedImageResourceGroupName: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          MANAGED_IMAGE_NAME=$(sed -n "s/^ManagedImageName: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          MANAGED_IMAGE_ID=$(sed -n "s/^ManagedImageId: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          MANAGED_IMAGE_LOCATION=$(sed -n "s/^ManagedImageLocation: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          MANAGED_IMAGE_SHARED_IMAGE_GALLERY_ID=$(sed -n "s/^ManagedImageSharedImageGalleryId: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          SHARED_IMAGE_GALLERY_RESOURCE_GROUP=$(sed -n "s/^SharedImageGalleryResourceGroup: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          SHARED_IMAGE_GALLERY_NAME=$(sed -n "s/^SharedImageGalleryName: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          SHARED_IMAGE_GALLERY_IMAGE_NAME=$(sed -n "s/^SharedImageGalleryImageName: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          SHARED_IMAGE_GALLERY_IMAGE_VERSION=$(sed -n "s/^SharedImageGalleryImageVersion: \(.*\)/\1/p" $PACKER_OUTPUT | tail -1)
          TAGS=$(cat packer/azure/tags.out)

          if [[ ${SHARED_IMAGE_GALLERY_IMAGE_NAME} == *gen2 ]]; then
            HYPERV_GEN="V2"
          else
            HYPERV_GEN="V1"
          fi

          # Create JSON and output it
          PUBLISHING_INFO=$(cat <<EOF
          {
            "distro": "${DISTRO}",
            "hyperv_gen": "${HYPERV_GEN}",
            "os_type": "${OS_TYPE}",
            "managed_image_resource_group_name": "${MANAGED_IMAGE_RESOURCE_GROUP_NAME}",
            "managed_image_name": "${MANAGED_IMAGE_NAME}",
            "managed_image_id": "${MANAGED_IMAGE_ID}",
            "managed_image_location": "${MANAGED_IMAGE_LOCATION}",
            "managed_image_shared_image_gallery_id": "${MANAGED_IMAGE_SHARED_IMAGE_GALLERY_ID}",
            "shared_image_gallery_resource_group": "${SHARED_IMAGE_GALLERY_RESOURCE_GROUP}",
            "shared_image_gallery_name": "${SHARED_IMAGE_GALLERY_NAME}",
            "shared_image_gallery_image_name": "${SHARED_IMAGE_GALLERY_IMAGE_NAME}",
            "shared_image_gallery_image_version": "${SHARED_IMAGE_GALLERY_IMAGE_VERSION}",
            "tags": "${TAGS}"
          }
          EOF
          )

          # Compact JSON for output
          echo "info=$(echo "${PUBLISHING_INFO}" | jq -c .)" >> $GITHUB_OUTPUT

          # Save to file for artifact
          echo "${PUBLISHING_INFO}" > packer/azure/sig-publishing-info.json

      - name: Upload publishing info artifact
        uses: actions/upload-artifact@v4
        with:
          name: publishing-info
          path: images/capi/packer/azure/sig-publishing-info.json
          retention-days: 7
