# Reusable workflow for testing Azure SIG images
#
# This workflow creates a test cluster using the built image and validates
# that the image works correctly.

name: Test Azure SIG Image

on:
  workflow_call:
    inputs:
      kubernetes_version:
        description: 'Kubernetes version (e.g., 1.31.1)'
        required: true
        type: string
      publishing_info:
        description: 'JSON object containing image publishing information'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  test_sig:
    name: Test SIG Image
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      KUBERNETES_VERSION: ${{ inputs.kubernetes_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download publishing info artifact
        uses: actions/download-artifact@v4
        with:
          name: publishing-info
          path: images/capi/packer/azure/sig/

      - name: Import variables from build
        id: vars
        run: |
          set -euo pipefail

          PUBLISHING_INFO='${{ inputs.publishing_info }}'

          echo "OS_TYPE=$(echo $PUBLISHING_INFO | jq -r .os_type)" >> $GITHUB_OUTPUT
          echo "MANAGED_IMAGE_RESOURCE_GROUP_NAME=$(echo $PUBLISHING_INFO | jq -r .managed_image_resource_group_name)" >> $GITHUB_OUTPUT
          echo "MANAGED_IMAGE_NAME=$(echo $PUBLISHING_INFO | jq -r .managed_image_name)" >> $GITHUB_OUTPUT
          echo "MANAGED_IMAGE_ID=$(echo $PUBLISHING_INFO | jq -r .managed_image_id)" >> $GITHUB_OUTPUT
          echo "MANAGED_IMAGE_LOCATION=$(echo $PUBLISHING_INFO | jq -r .managed_image_location)" >> $GITHUB_OUTPUT
          echo "MANAGED_IMAGE_SHARED_IMAGE_GALLERY_ID=$(echo $PUBLISHING_INFO | jq -r .managed_image_shared_image_gallery_id)" >> $GITHUB_OUTPUT
          echo "SHARED_IMAGE_GALLERY_RESOURCE_GROUP=$(echo $PUBLISHING_INFO | jq -r .shared_image_gallery_resource_group)" >> $GITHUB_OUTPUT
          echo "SHARED_IMAGE_GALLERY_NAME=$(echo $PUBLISHING_INFO | jq -r .shared_image_gallery_name)" >> $GITHUB_OUTPUT
          echo "SHARED_IMAGE_GALLERY_IMAGE_NAME=$(echo $PUBLISHING_INFO | jq -r .shared_image_gallery_image_name)" >> $GITHUB_OUTPUT
          echo "SHARED_IMAGE_GALLERY_IMAGE_VERSION=$(echo $PUBLISHING_INFO | jq -r .shared_image_gallery_image_version)" >> $GITHUB_OUTPUT
          echo "TAGS=$(echo $PUBLISHING_INFO | jq -r .tags)" >> $GITHUB_OUTPUT

      - name: Configure Kubernetes version
        working-directory: images/capi/packer/config
        run: |
          KUBERNETES_RELEASE=$(echo ${KUBERNETES_VERSION} | cut -d "." -f -2)
          sed -i "s/^  \"kubernetes_series\".*/  \"kubernetes_series\": \"v${KUBERNETES_RELEASE}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_semver\".*/  \"kubernetes_semver\": \"v${KUBERNETES_VERSION}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_rpm_version\".*/  \"kubernetes_rpm_version\": \"${KUBERNETES_VERSION}\",/g" kubernetes.json
          sed -i "s/^  \"kubernetes_deb_version\".*/  \"kubernetes_deb_version\": \"${KUBERNETES_VERSION}-1.1\",/g" kubernetes.json

      - name: Setup kustomize
        working-directory: images/capi
        run: |
          export PATH=${PATH}:.local/bin
          ./packer/azure/scripts/ensure-kustomize.sh

      - name: Generate cluster template
        working-directory: images/capi
        run: |
          set -euo pipefail
          export PATH=${PATH}:.local/bin

          OS_TYPE="${{ steps.vars.outputs.OS_TYPE }}"

          if [ "$OS_TYPE" == "Windows" ]; then
            kustomize build --load-restrictor LoadRestrictionsNone packer/azure/scripts/test-templates/windows/ > packer/azure/scripts/test-templates/cluster-template.yaml
          else
            kustomize build --load-restrictor LoadRestrictionsNone packer/azure/scripts/test-templates/linux/ > packer/azure/scripts/test-templates/cluster-template.yaml
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure CAPI extension
        run: |
          set -euo pipefail

          # Install the Azure CLI Cluster API extension from the official release
          az extension add --name capi --yes || az extension add --source "https://github.com/Azure/azure-capi-cli-extension/releases/latest/download/capi-0.0.vnext-py2.py3-none-any.whl" --yes

          # Install required binaries
          mkdir -p ~/test-binaries
          export PATH=${PATH}:~/test-binaries
          az capi install -a -ip ~/test-binaries

      - name: Create test cluster
        working-directory: images/capi
        run: |
          set -euo pipefail

          OS_TYPE="${{ steps.vars.outputs.OS_TYPE }}"
          MANAGED_IMAGE_RESOURCE_GROUP_NAME="${{ steps.vars.outputs.MANAGED_IMAGE_RESOURCE_GROUP_NAME }}"
          MANAGED_IMAGE_LOCATION="${{ steps.vars.outputs.MANAGED_IMAGE_LOCATION }}"
          TAGS="${{ steps.vars.outputs.TAGS }}"
          TEST_TEMPLATE="packer/azure/scripts/test-templates/cluster-template.yaml"

          export PATH=${PATH}:~/test-binaries

          params=()
          if [ "$OS_TYPE" == "Windows" ]; then
            params+=(--windows)
          fi

          RESOURCE_GROUP=${MANAGED_IMAGE_RESOURCE_GROUP_NAME}
          AZURE_LOCATION=${MANAGED_IMAGE_LOCATION}

          # Create a cluster
          az capi create \
            --yes \
            --debug \
            --name testvm \
            --kubernetes-version="${KUBERNETES_VERSION}" \
            --location="${AZURE_LOCATION}" \
            --resource-group="${RESOURCE_GROUP}" \
            --management-cluster-resource-group-name="${RESOURCE_GROUP}" \
            --control-plane-machine-count=1 \
            --node-machine-count=1 \
            --template="${TEST_TEMPLATE}" \
            --tags="${TAGS}" \
            --wait-for-nodes=2 \
            "${params[@]}"

          # Test if the VM's provisionState is "Succeeded" otherwise fail
          timeout 60s bash -c "while ! az vm list -g ${RESOURCE_GROUP} | jq -e 'all(.provisioningState == \"Succeeded\")'; do sleep 1; done"

      - name: Clean up test resource group
        if: always()
        run: |
          set -euo pipefail

          RESOURCE_GROUP="${{ steps.vars.outputs.MANAGED_IMAGE_RESOURCE_GROUP_NAME }}"
          echo "Cleaning up resource group: ${RESOURCE_GROUP}"
          az group delete -n "${RESOURCE_GROUP}" --yes --no-wait || true
