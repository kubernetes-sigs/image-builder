$DriveLetter = "M"
$Label = "cidata"
$metadata = "meta-data"
$userdata = "user-data"
$metadataPath = "${DriveLetter}:\${metadata}"
$userdataPath = "${DriveLetter}:\${userdata}"
$logfile = "$env:SystemRoot\OEM\SetupComplete2_test.log"

# Find the first uninitialized disk
$UninitializedDisk = Get-Disk | Where-Object PartitionStyle -EQ "Raw" | Select-Object -First 1

if ($UninitializedDisk) {
    $DiskNumber = $UninitializedDisk.Number

    Initialize-Disk -Number $DiskNumber -PartitionStyle MBR
    $Partition = New-Partition -DiskNumber $DiskNumber -UseMaximumSize -AssignDriveLetter
    Format-Volume -DriveLetter $Partition.DriveLetter -FileSystem FAT32 -NewFileSystemLabel $Label -Confirm:$false
    Set-Partition -DriveLetter $Partition.DriveLetter -NewDriveLetter $DriveLetter

    # Create a YAML file with the hostname which was already configured via Azure Provisioner
    # Valid yaml file is required to set up the NoCloud service otherwise the service instantiation won't work
    # setting local-hostname allows for the use of instance metadata in CAPZ in the format "ds.meta_data["local_hostname"]"
    # which is generated by a CAPI component for the kubeadm JoinConfiguration
    # https://cloudinit.readthedocs.io/en/latest/explanation/instancedata.html  
    # https://github.com/cloudbase/cloudbase-init/blob/aa06aeeecdb42053d09e48d00647dce3439009ec/cloudbaseinit/metadata/services/nocloudservice.py#L578
    $Hostname = $env:COMPUTERNAME
    "local-hostname: $Hostname" | Out-File -Encoding ASCII -FilePath $metadataPath

    # move the custom data that was provisioned via Azure to the drive so cloud base can process it
    cp $env:SystemDrive\AzureData\CustomData.bin $userdataPath
    icacls $userdataPath /inheritance:r /grant:r  --% *S-1-5-18:(OI)(CI)F *S-1-5-32-544:(OI)(CI)F

    $LogMessage = "Formated and configured disk $DiskNumber as $DriveLetter with $Label"
    $LogMessage | Out-File -FilePath $logfile  -Append -Encoding UTF8 
} else {
    $LogMessage = "No uninitialized disks found. Cloudbase-init may not run"
    $LogMessage | Out-File -FilePath $logfile -Append -Encoding UTF8
}
